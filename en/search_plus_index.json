{"./":{"url":"./","title":"About Tang Nano","keywords":"","body":"Tang Nano Document --> What is Tang Nano? The Lichee Tang Nano is a compact development board based on the GW1N-1 FPGA from the Gaoyun Little Bee series. The onboard chip is GW1N-LV1QN48C6/I5, equipped with 1152 LUT4 logic resources, 1 PLL and 4 Block total 72Kbit SRAM, packaged as QFN48. The development board brings out all I/O interfaces for the design and experimentation of small digital logic. Onboard 64Mbits PSRAM provides a rich storage resource for FPGAs. At the same time, the development board has an RGB interface that can be connected to peripherals such as LCD screens and VGA converters, making it ideal for applications such as screen displays. The board's onboard 24MHz crystal and USB to JTAG downloader make it easy to connect to a PC for development without the need for an external debugger and clock input. The onboard RGB LEDs can be used for indication and debugging, while the FPGA IOBANK group's adjustable IO levels allow the development board to easily interface with externally different level specifications. Onboard resources: GW1N-1 64Mbit QSPI PSRAM RGB LED RGB LCD 40P interface and drive circuit 24MHz crystal USB debugger, based on Type-C communication interface Pinout Diagram Resource download link GoWin official download station dl Download station Tang nano Schematic.pdf) "},"get_started/install-the-ide.html":{"url":"get_started/install-the-ide.html","title":"IDE installation","keywords":"","body":"Download Go to the official website http://www.gowinsemi.com.cn/faq.aspx, you can see the software list below, select the version of the system suitable for the computer to download. Installation Windows User: Double-click the downloaded exe installation file, select the installation language, installation location, click the next step to complete the installation. Be sure to install the driver that prompts you to install when you complete the installation. Check the installation driver and click Finish, the driver will be installed. Linux User: TODO license There are currently two ways to license. The first type: use the stand-alone version of the licence (need to apply for license) Send an application email to Support@sipeed.com under the heading [Apply Tang Lic] MAC: XXXXXX. The content template is as follows Company Name: Company Website: Department: Contact Person: Contact No.: Email: Media Access Control Address(MAC): Type of License: Shared Type, Local Only Operating System: Windows, Linux When you open the High Cloud IDE, in the license management that pops up, select your local license path. Then you need to add the path of the license of synplifypro to the system variable. The following is a brief introduction to an add method. In `The second: use the sipeed license server networking activation, there is a more detailed introduction. Windows User press win+r on the keyboard, enter cmd in the pop-up window, click OK to pop up the black command line window, enter the following command, path_to_the_file is your gowin_Synplifypro.lic Path of. setx LM_LICENSE_FILE path_to_the_file Second: Network activation with license server using sipeed This method is simple to configure, but you can't use the software without a network. After downloading the software, the software will prompt you for a licence. Fill in the server address 45.33.107.56 in the pop-up box, IDE port: 10559. The activation of the synopsys advanced function requires adding the environment variable LM_LICENSE_FILE=27020@45.33.107.56 to the system. Windows User presses win+r on the keyboard, enter cmd in the pop-up window, click OK to pop up the black command line window, enter the following command. setx LM_LICENSE_FILE 27020@45.33.107.56 Windows can be added in addition to the command line. You can also add it by right-clicking Computer->Properties->Environment Variables and then adding it as shown below. Linux users need to add in ~/.bashrc Export LM_LICENSE_FILE 27020@45.33.107.56 After entering the IDE, click on Synplify Pro in Tools. Then the interface will pop up as shown below. At this time, you need to wait for a short time. After the license is initialized, you can use it. Instructions Refer to the official documentation [Gowin Source Software User Guide] (http://cdn.gowinsemi.com.cn/SUG100-1.8_Gowin%E4%BA%91%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf), Chapter 5 Cloud Source Software Usage. Reference document Gowin Software Introduction and Installation "},"examples/1_led.html":{"url":"examples/1_led.html","title":"Lighting tutorial","keywords":"","body":"Instance process New Project -> Add Source Code File -> Add Timing, Pin Constraints -> Synthesis -> Programe Before reading this document, please make sure you have seen [Gowin Cloud Source Software User Guide] (http://cdn.gowinsemi.com.cn/SUG100-1.8_Gowin%E4%BA%91%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf), Chapter 5 Cloud Source Software Usage The source code of this experiment: https://github.com/sipeed/Tang-Nano-examples/tree/master/example_led Verilog Prerequisites Here only introduce the relevant syntax that will be used next, more can refer to Verilog Tutorial The basic design unit of Verilog is the module, and each Verilog program consists of four main parts: port definition, I/O description, internal signal declaration and function definition. The module is like the black box we usually mentioned. When we implement the module, we don't need to care about the inside of the module. We only need to instantiate the module according to the input and output format defined by the module, and provide input to the module. Already working a module grows like this module block (input a, output b); reg [width-1:0] R_1; assign b = a; always @(posedge clk or negedge reset_n) begin // do something end endmodule The overall structure of the module consists of module and endmodule. The module is followed by the definition of the module interface, which declares whether the direction of the port is input or output. Internal signals are sometimes used inside the module, and the internal signals are of type wire and reg. The definition of the function can be done through the assign and always blocks. Assign is one of the most common methods for describing combinatorial logic; always a block machine can be used to describe combinatorial logic, as well as to describe sequential logic Pin usage The onboard is a RGB(tri-color) LED, the schematic is as follows The pin distribution used by the entire program is as follows port I/O pin desc sys_clk input 35 Clock Input Pin sys_rst_n input 15 System Reset Foot led[0] output 16 Green LED led[1] output 17 Blue LED led[2] output 18 Red LED Programming The clock of this system is 24Mhz, one machine cycle is 1/24M s, which means 0.5s every 12000000 clock cycles. In the program, calculate 12000000 clock cycles by counter, and wait for 0.5s. After the time is up, set counter to 0 and change the color of the LED. module led ( input sys_clk, // clk input input sys_rst_n, // reset input output reg [2:0] led // 110 G, 101 R, 011 B ); reg [23:0] counter; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) counter Pin constraint In order for fpga to implement the function of the code, it is also necessary to constrain the pin operations involved in the code to the actual pins of fpga. As shown below, click process in the workspace on the left, then double-click FloorPlanner The first click in the project, you may be prompted to create a file, click OK In the pop-up window, switch to Package View, drag the port under Ports to the corresponding pin of fpga, save it, as shown below Synthesis In the workspace on the left, right-click Synthesize or Place&Route, there will be a run option, click Programe There are two options, one is to burn to sram, the other is to burn to flash. Burning to sram is faster, but there is no firmware in fpga after power-off; burning to flash can save the firmware before burning after the system is powered off. Burning is done through the Programer Double-click on the Program Device in the left workspace to open the Programer. However, before using Programer, you need to be aware that you can use Programer after both Synthesize and Place&Route are completed, otherwise the software will report error Bitstream file dose not exists Linux users need to pay attention The programmer in the Linux installation package is for Linux version Red Hat 5.10. For the Red Hat 6/7 version of the programmer, please download the installation on the official website and replace the installation package with the file in the Gowin cloud source software installation package. Clip \"Programmer\". Change the burning position To select the location where the firmware is programmed, you can click Edit -> Configure Device when the chip is selected. In the pop-up window, select the location you want to burn. The flash is selected here. The default burning location is sram. Burning After selecting the burning location, you can burn the firmware, click on the menu bar to burn. "},"examples/2_lcd.html":{"url":"examples/2_lcd.html","title":"Point LCD tutorial","keywords":"","body":"RGB LCD example Introduce timing first The principle of RGB LCD display image is similar to that of VGA. It is to digitally generate the image information to be displayed inside the computer, and then convert the image information of these numbers into RGB three primary color analog signals through analog-to-digital conversion. Field sync signal. The timing of VGA is introduced below. The above figure is the line synchronization and field synchronization timing of VGA in data transmission. As can be seen from the timing diagram, whether a line of data or a column of data is required, a synchronization (sync) signal is required, and the transmission of data needs to be completed between the pulses of the two synchronization signals. The data for each line includes the back porch, active viedo, and front porch. The valid data is the resolution we often say, and the parameters of the leading and trailing edges need to be set with reference to the specific resolution and number of frames. The relevant parameters can refer to the typical parameters, and the link is here: http://www.tinyvga.com /vga-timing The control timing of this screen is slightly different. You can view the [Specifications] (../../assets/files/AT050TN43.pdf) Screenshots of LCD related timing are provided below The above picture is the parameter table in the timing, and the following picture is the timing chart. As seen from the timing diagram, this screen can be set without the front and rear edges, and only the blanking time can be set. It can be proved by the actual program that both methods are possible. Verilog implementation 1.pll The onboard crystal clock is 24MHz, but our screen requires a 33.3MHZ clock, so we need to use pll to generate the clock we need. Need to use IP Core Generate here, located in Tools -> IP Core Generate Double-click PLL, select Verilog in the pop-up window language, CLKIN is 24MHz, CLKOUT is 200MHz, CLKOUTD should select Enable, then generate clock is 33.33MHz, Tolerance selects 0.2% 2.osc The system clock can be provided by an external clock or by using an OSC generated clock. Also use IP Core Generate Find OSC and double-click to open the settings for crossover. As you can see on the help page, the OSC of the GW1N-1 series fpga is divided from 240MHz, so to generate a 24MHz clock, only need to divide by 10 3.lcd timing generation localparam V_BackPorch = 16'd6; //0 or 45 localparam V_Pluse = 16'd5; localparam HightPixel = 16'd480; localparam V_FrontPorch= 16'd62; //45 or 0 localparam H_BackPorch = 16'd182; //NOTE: When the high pixel clock is used, increase the delay here to facilitate the K210 to join the interrupt. localparam H_Pluse = 16'd1; localparam WidthPixel = 16'd800; localparam H_FrontPorch= 16'd210; localparam PixelForHS = WidthPixel + H_BackPorch + H_FrontPorch; localparam LineForVS = HightPixel + V_BackPorch + V_FrontPorch; The first is to set the timing related parameters: leading edge, trailing edge, effective pixels Regarding the display leading edge and trailing edge, as mentioned earlier, it can be combined into one erasing time, that is, one can be set to 0 and the other to the erasing time. Anyway, the time between the front and the back adds up to meet the time requirements in the table. always @( posedge PixelClk or negedge nRST ) begin if( !nRST ) begin LineCount = H_Pluse)&&( PixelCount = V_Pluse )&&( LineCount This code generates a sync signal. It should be noted that the sync signal of this screen is negative polarity enabled. assign LCD_DE = ( ( PixelCount >= H_BackPorch )&& ( PixelCount = V_BackPorch ) && ( LineCount This code sets the LCD to enable image display. This screen needs to control one pin to be used as a display switch. The actual signal is set when the 800*480 data is valid for transmitting images. assign LCD_R = (PixelCountThis code is used to generate test data for the LCD to produce a color bar display. VGAMod D1 ( .CLK ( CLK_SYS ), .nRST ( nRST ), .PixelClk ( CLK_PIX ), .LCD_DE ( LCD_DEN ), .LCD_HSYNC ( LCD_HYNC ), .LCD_VSYNC ( LCD_SYNC ), .LCD_B ( LCD_B ), .LCD_G ( LCD_G ), .LCD_R ( LCD_R ) ); Finally, instantiate in TOP The entire project can be found at [https://github.com/sipeed/Tang-Nano-examples/tree/master/example_lcd][https://github.com/sipeed/Tang-Nano-examples/tree/master/example_lcd] download "}}